<!doctype html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Cartoon AI 3D (GitHub Only)</title>
  <style>
    html, body { margin:0; height:100%; background:#0b0f14; overflow:hidden; touch-action:manipulation; }
    canvas { display:block; width:100vw; height:100vh; }
    /* Dashboard overlay (ซ่อนใน Face mode) */
    #dash{
      position:fixed; inset:0; display:none;
      background:rgba(11,15,20,.95);
      color:#e7eef7;
      font:14px system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      padding:12px;
    }
    #dash .grid{ display:grid; grid-template-columns:1fr; gap:10px; max-width:900px; margin:0 auto; }
    #camWrap{ border:1px solid rgba(31,43,60,.85); border-radius:16px; overflow:hidden; background:#000; }
    video{ width:100%; height:auto; display:block; }
    .card{
      border:1px solid rgba(31,43,60,.85);
      border-radius:16px;
      background:rgba(18,26,36,.9);
      padding:10px 12px;
      white-space:pre-wrap;
      line-height:1.35;
    }
    .muted{ color: rgba(231,238,247,.65); font-size:12px; }
  </style>
</head>
<body>
  <section id="dash">
    <div class="grid">
      <div id="camWrap"><video id="video" playsinline autoplay muted></video></div>
      <div class="card" id="events"></div>
      <div class="card" id="memory"></div>
      <div class="card muted">
Gesture:
- แตะ 1 ครั้ง: “ตื่น/ทัก/ทำท่าทาง” + พูด (TTS ของเครื่อง)
- แตะ 2 ครั้ง: สลับ Face ↔ Dashboard
- กดค้าง 1 วินาที (เฉพาะ Dashboard): สลับกล้องหน้า/หลัง
      </div>
    </div>
  </section>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

    // -----------------------------
    // State + local memory (GitHub only)
    // -----------------------------
    let mode = "face";     // face | dash
    let armed = false;     // silent until first tap
    let useFront = true;
    let mediaStream = null;

    const dash = document.getElementById("dash");
    const video = document.getElementById("video");
    const eventsEl = document.getElementById("events");
    const memoryEl = document.getElementById("memory");

    const MEM_KEY = "cartoon_ai_3d_github_only_v1";
    const mem = JSON.parse(localStorage.getItem(MEM_KEY) || "{}");
    if (!mem.greetCount) mem.greetCount = 0;
    if (!mem.lastSpoken) mem.lastSpoken = "ยังไม่มี";

    function saveMem(){
      localStorage.setItem(MEM_KEY, JSON.stringify(mem));
      memoryEl.textContent =
`Memory (localStorage):
- greetCount: ${mem.greetCount}
- lastSpoken: ${mem.lastSpoken}`;
    }
    function logEvent(msg){
      const line = `[${new Date().toLocaleTimeString()}] ${msg}\n`;
      eventsEl.textContent = line + (eventsEl.textContent || "");
    }
    saveMem();
    logEvent("Ready (silent until first tap)");

    // -----------------------------
    // Scene
    // -----------------------------
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0f14);

    const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 100);
    camera.position.set(0, 0.35, 3.2);

    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    document.body.insertBefore(renderer.domElement, dash);

    // Lights
    scene.add(new THREE.AmbientLight(0xffffff, 0.35));
    const key = new THREE.DirectionalLight(0xffffff, 1.0); key.position.set(2, 3, 3); scene.add(key);
    const fill = new THREE.DirectionalLight(0xffffff, 0.55); fill.position.set(-2, 1.5, 2); scene.add(fill);
    const rim = new THREE.DirectionalLight(0xffffff, 0.45); rim.position.set(0, 2, -3); scene.add(rim);

    // -----------------------------
    // Cartoon character (chibi)
    // -----------------------------
    const root = new THREE.Group();
    scene.add(root);

    const matSkin = new THREE.MeshStandardMaterial({ color: 0xE9F2FF, roughness: 0.35, metalness: 0.03 });
    const matDark = new THREE.MeshStandardMaterial({ color: 0x0b0f14, roughness: 0.75, metalness: 0.0 });
    const matCheek = new THREE.MeshStandardMaterial({ color: 0xFFB3C7, roughness: 0.6, metalness: 0.0 });
    const matBody  = new THREE.MeshStandardMaterial({ color: 0x4da3ff, roughness: 0.5, metalness: 0.05 });

    // Head group (so we can nod/tilt)
    const headG = new THREE.Group();
    headG.position.set(0, 0.65, 0);
    root.add(headG);

    const head = new THREE.Mesh(new THREE.SphereGeometry(0.95, 48, 48), matSkin);
    headG.add(head);

    // Cheeks
    const cheekGeo = new THREE.SphereGeometry(0.16, 24, 24);
    const cheekL = new THREE.Mesh(cheekGeo, matCheek);
    const cheekR = new THREE.Mesh(cheekGeo, matCheek);
    cheekL.position.set(-0.48, -0.20, 0.72);
    cheekR.position.set( 0.48, -0.20, 0.72);
    cheekL.scale.set(1.2, 0.9, 0.6);
    cheekR.scale.set(1.2, 0.9, 0.6);
    headG.add(cheekL, cheekR);

    // Eyes (big cute)
    const eyeWhite = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.25, metalness: 0.0 });
    const eyeGeo = new THREE.SphereGeometry(0.20, 28, 28);
    const pupilGeo = new THREE.SphereGeometry(0.085, 24, 24);

    const eyeL = new THREE.Mesh(eyeGeo, eyeWhite);
    const eyeR = new THREE.Mesh(eyeGeo, eyeWhite);
    const pupilL = new THREE.Mesh(pupilGeo, matDark);
    const pupilR = new THREE.Mesh(pupilGeo, matDark);

    eyeL.position.set(-0.36, 0.20, 0.72);
    eyeR.position.set( 0.36, 0.20, 0.72);
    pupilL.position.set(-0.36, 0.18, 0.86);
    pupilR.position.set( 0.36, 0.18, 0.86);

    headG.add(eyeL, eyeR, pupilL, pupilR);

    // Mouth (smile capsule; we scale Y while speaking)
    const mouth = new THREE.Mesh(new THREE.CapsuleGeometry(0.16, 0.02, 8, 16), matDark);
    mouth.position.set(0, -0.25, 0.78);
    mouth.rotation.z = Math.PI / 2;
    headG.add(mouth);

    // Body (simple rounded capsule)
    const bodyG = new THREE.Group();
    bodyG.position.set(0, -0.10, 0);
    root.add(bodyG);

    const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.35, 0.55, 10, 20), matBody);
    body.rotation.x = Math.PI / 2; // make it stand upright
    bodyG.add(body);

    // Arms (two small capsules on sides)
    const armGeo = new THREE.CapsuleGeometry(0.10, 0.35, 8, 16);
    const armL = new THREE.Mesh(armGeo, matSkin);
    const armR = new THREE.Mesh(armGeo, matSkin);

    const armLG = new THREE.Group();
    const armRG = new THREE.Group();
    armLG.position.set(-0.55, 0.05, 0.0);
    armRG.position.set( 0.55, 0.05, 0.0);
    bodyG.add(armLG, armRG);

    armL.rotation.z = Math.PI / 2;
    armR.rotation.z = Math.PI / 2;
    armLG.add(armL);
    armRG.add(armR);

    // Hands (tiny spheres)
    const handGeo = new THREE.SphereGeometry(0.12, 18, 18);
    const handL = new THREE.Mesh(handGeo, matSkin);
    const handR = new THREE.Mesh(handGeo, matSkin);
    handL.position.set(0.25, 0, 0);
    handR.position.set(0.25, 0, 0);
    armL.add(handL);
    armR.add(handR);

    // Feet shadow (simple disc)
    const shadow = new THREE.Mesh(
      new THREE.CircleGeometry(0.55, 40),
      new THREE.MeshStandardMaterial({ color: 0x101826, roughness: 1, metalness: 0 })
    );
    shadow.rotation.x = -Math.PI/2;
    shadow.position.set(0, -0.90, 0);
    shadow.scale.set(1.2, 1.2, 1.2);
    scene.add(shadow);

    // -----------------------------
    // Animation helpers
    // -----------------------------
    let t = 0;
    let speaking = false;

    // Blink
    let blinkState = 0; // 0 open, 1 closing, 2 opening
    let blinkT = 0;
    let nextBlinkAt = 1.2 + Math.random() * 2.6;
    function blinkOnce(){ blinkState = 1; blinkT = 0; }

    // Emote/action state machine
    let action = "idle"; // idle | wave | nod | yay | curious
    let actionTime = 0;

    function setAction(a, dur=1.2){
      action = a;
      actionTime = dur;
      logEvent(`Action -> ${a}`);
    }

    function pickRandomAction(){
      const pool = ["wave","nod","yay","curious"];
      return pool[Math.floor(Math.random()*pool.length)];
    }

    // -----------------------------
    // Speech (local TTS only)
    // -----------------------------
    function speak(text){
      if (!armed) return;
      speaking = true;
      mem.lastSpoken = text;
      saveMem();

      const u = new SpeechSynthesisUtterance(text);
      u.lang = "th-TH";
      u.rate = 1.0;
      u.pitch = 1.0;

      u.onend = () => { speaking = false; };
      speechSynthesis.cancel();
      speechSynthesis.speak(u);
    }

    function politeLine(){
      const lines = [
        "สวัสดีครับ ผมพร้อมช่วยคุณครับ",
        "รับทราบครับ ต้องการให้ช่วยเรื่องใดเพิ่มเติมครับ",
        "ได้ครับ หากต้องการเปิดกล้อง ให้ดับเบิลแท็ปเพื่อไปโหมดแดชบอร์ดครับ",
        "ยินดีครับ ผมอยู่ตรงนี้เสมอครับ"
      ];
      return lines[Math.floor(Math.random()*lines.length)];
    }

    // -----------------------------
    // Camera (Dashboard only)
    // -----------------------------
    async function stopCamera(){
      if (mediaStream) {
        mediaStream.getTracks().forEach(tr => tr.stop());
        mediaStream = null;
      }
      video.srcObject = null;
    }

    async function startCamera(){
      await stopCamera();
      const constraints = {
        audio:false,
        video:{ facingMode: useFront ? "user":"environment", width:{ideal:1280}, height:{ideal:720} }
      };
      mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
      video.srcObject = mediaStream;
      logEvent(`Camera on (${useFront ? "front":"back"})`);
    }

    function setMode(nextMode){
      mode = nextMode;
      if (mode === "dash") {
        dash.style.display = "block";
        startCamera().catch(() => logEvent("Camera permission denied"));
      } else {
        dash.style.display = "none";
        stopCamera();
      }
      logEvent(`Mode -> ${mode}`);
    }

    // -----------------------------
    // No buttons: gestures
    // - single tap: first = arm/unlock + greet + wave; next = random emote + speak
    // - double tap: toggle mode
    // - long press (>=650ms): toggle camera (dash only)
    // -----------------------------
    let tapTimer = null;
    let lastTapAt = 0;
    let pressTimer = null;
    let pressed = false;

    function onSingleTap(){
      if (!armed) {
        armed = true;
        mem.greetCount += 1;
        saveMem();
        logEvent("Armed (silent -> active)");

        setAction("wave", 1.4);
        blinkOnce();
        speak("สวัสดีครับ ผมเป็นผู้ช่วยบนหน้าจอ พร้อมช่วยคุณแล้วครับ");
        return;
      }

      const a = pickRandomAction();
      setAction(a, 1.2);
      blinkOnce();
      speak(politeLine());
    }

    function onDoubleTap(){
      if (!armed) {
        armed = true;
        logEvent("Armed (by double tap)");
      }
      setAction("nod", 0.9);
      setMode(mode === "face" ? "dash" : "face");
      blinkOnce();
    }

    function onLongPress(){
      if (mode !== "dash") return;
      useFront = !useFront;
      startCamera().catch(() => logEvent("Camera switch failed"));
      setAction("curious", 1.1);
      blinkOnce();
    }

    window.addEventListener("pointerdown", () => {
      pressed = true;
      pressTimer = setTimeout(() => {
        if (pressed) {
          if (tapTimer) { clearTimeout(tapTimer); tapTimer = null; }
          onLongPress();
        }
      }, 650);
    }, { passive:true });

    window.addEventListener("pointerup", () => {
      pressed = false;
      if (pressTimer) { clearTimeout(pressTimer); pressTimer = null; }

      const now = Date.now();
      const dt = now - lastTapAt;
      lastTapAt = now;

      if (dt > 0 && dt < 280) {
        if (tapTimer) { clearTimeout(tapTimer); tapTimer = null; }
        onDoubleTap();
      } else {
        tapTimer = setTimeout(() => {
          onSingleTap();
          tapTimer = null;
        }, 300);
      }
    }, { passive:true });

    // -----------------------------
    // Render loop
    // -----------------------------
    function animate(){
      requestAnimationFrame(animate);
      t += 0.016;

      // Idle "breathing" + tiny sway
      const breathe = Math.sin(t*1.6) * 0.02;
      root.position.y = breathe - 0.02;
      root.rotation.y = Math.sin(t*0.35) * 0.08;

      // Pupils wander (cute)
      const px = Math.sin(t*0.9) * 0.03;
      const py = Math.cos(t*0.8) * 0.02;
      pupilL.position.x = -0.36 + px;
      pupilR.position.x =  0.36 + px;
      pupilL.position.y =  0.18 + py;
      pupilR.position.y =  0.18 + py;

      // Mouth animation while speaking
      if (speaking) {
        const s = 1.0 + (Math.sin(t*18) * 0.25 + 0.25);
        mouth.scale.y = s;
        mouth.scale.x = 1.0 + (Math.sin(t*18) * 0.10);
      } else {
        // keep slight smile
        mouth.scale.set(1, 1, 1);
      }

      // Blink schedule
      nextBlinkAt -= 0.016;
      if (nextBlinkAt <= 0) {
        blinkOnce();
        nextBlinkAt = 1.2 + Math.random() * 2.8;
      }

      // Blink animation
      if (blinkState !== 0) {
        blinkT += 0.07;
        if (blinkState === 1) {
          const k = Math.max(0.08, 1 - blinkT);
          eyeL.scale.y = k; eyeR.scale.y = k;
          if (blinkT >= 1) { blinkState = 2; blinkT = 0; }
        } else {
          const k = Math.min(1, blinkT);
          eyeL.scale.y = k; eyeR.scale.y = k;
          if (blinkT >= 1) { blinkState = 0; eyeL.scale.y = 1; eyeR.scale.y = 1; }
        }
      }

      // Action animations
      if (actionTime > 0) actionTime -= 0.016;
      if (actionTime <= 0 && action !== "idle") action = "idle";

      // Reset default poses (smooth return)
      const lerp = (a,b,k)=>a+(b-a)*k;

      // Head default
      headG.rotation.x = lerp(headG.rotation.x, 0, 0.08);
      headG.rotation.z = lerp(headG.rotation.z, 0, 0.08);

      // Arms default (down)
      armLG.rotation.z = lerp(armLG.rotation.z, 0.15, 0.10);
      armRG.rotation.z = lerp(armRG.rotation.z,-0.15, 0.10);
      armLG.rotation.x = lerp(armLG.rotation.x, 0.0, 0.10);
      armRG.rotation.x = lerp(armRG.rotation.x, 0.0, 0.10);

      // Actions
      if (action === "wave") {
        // right arm wave
        const w = Math.sin(t*14) * 0.7;
        armRG.rotation.z = lerp(armRG.rotation.z, -1.2, 0.22);
        armRG.rotation.x = lerp(armRG.rotation.x, w, 0.35);
        headG.rotation.z = lerp(headG.rotation.z, -0.08, 0.12);
      } else if (action === "nod") {
        const n = Math.sin(t*10) * 0.18;
        headG.rotation.x = lerp(headG.rotation.x, n, 0.25);
      } else if (action === "yay") {
        // both arms up
        const j = Math.sin(t*12) * 0.08;
        armLG.rotation.z = lerp(armLG.rotation.z,  1.15, 0.20);
        armRG.rotation.z = lerp(armRG.rotation.z, -1.15, 0.20);
        root.position.y += j;
        headG.rotation.x = lerp(headG.rotation.x, -0.08, 0.12);
      } else if (action === "curious") {
        headG.rotation.z = lerp(headG.rotation.z, 0.18, 0.18);
        headG.rotation.x = lerp(headG.rotation.x, -0.05, 0.18);
      }

      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener("resize", () => {
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // start silent in face mode
    setMode("face");
  </script>
</body>
</html>
